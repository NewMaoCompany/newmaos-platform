import json
import datetime

def escape_sql(value):
    if value is None:
        return "NULL"
    if isinstance(value, str):
        # Escape single quotes
        return "'" + value.replace("'", "''") + "'"
    if isinstance(value, bool):
        return "TRUE" if value else "FALSE"
    if isinstance(value, (int, float)):
        return str(value)
    if isinstance(value, (list, dict)):
        return "'" + json.dumps(value).replace("'", "''") + "'"
    return "NULL"

def escape_array(value):
    if value is None:
        return "NULL"
    if not value:
        return "'{}'"
    # value is list of strings
    items = [f"'{str(v).replace('\'', '\'\'')}'" for v in value]
    return f"ARRAY[{', '.join(items)}]"

def main():
    input_file = 'unit1_questions.json'
    output_file = 'upsert_unit1_questions.sql'
    
    with open(input_file, 'r') as f:
        questions = json.load(f)

    # 1. Collect Metadata (Topics, Skills, Error Tags)
    # We need to insert these first to avoid FK violations.
    # topic_id seems to be "Both_Limit".
    # We'll use sets to track unique items.
    
    topics = {} # id -> {title, description}
    skills = {} # id -> {name, unit}
    error_tags = {} # id -> {name, unit, severity, category}

    unique_sub_topics = set()
    unique_topic_ids = set()

    for q in questions:
        # Collect sub_topic/topic for DELETEs
        if 'sub_topic_id' in q:
            unique_sub_topics.add(q['sub_topic_id'])
        if 'topic_id' in q:
            unique_topic_ids.add(q['topic_id'])
            # Assuming topic title/desc usually matches ID or is generic
            # In the example SQL, they inserted into topic_content ('BC_Series', 'Infinite...', 'Unit 10...')
            # Here we just have "Both_Limits" or "Both_Limit".
            # We'll try to insert it if it doesn't exist.
            topics[q['topic_id']] = {
                'title': q['course'] + ' ' + q['topic_id'],
                'description': 'Unit 1 Limits'
            }

        # Skills
        # skill_tags is a list of strings
        # primary_skill_id is a string
        # supporting_skill_ids is a list of strings
        
        current_unit = q.get('topic_id', 'Both_Limit')
        
        all_skills = set()
        if 'skill_tags' in q and isinstance(q['skill_tags'], list):
            all_skills.update(q['skill_tags'])
        if 'primary_skill_id' in q and q['primary_skill_id']:
            all_skills.add(q['primary_skill_id'])
        if 'supporting_skill_ids' in q and isinstance(q['supporting_skill_ids'], list):
            all_skills.update(q['supporting_skill_ids'])
            
        for s_id in all_skills:
            if s_id not in skills:
                # We interpret the ID as the name if no other info
                skills[s_id] = {'name': s_id, 'unit': current_unit}

        # Error Tags
        if 'error_tags' in q and isinstance(q['error_tags'], list):
            for e_id in q['error_tags']:
                if e_id not in error_tags:
                    error_tags[e_id] = {
                        'name': e_id, 
                        'unit': current_unit, 
                        'severity': 1, 
                        'category': 'General'
                    }

    # Start writing SQL
    with open(output_file, 'w') as f:
        f.write("-- ============================================================\n")
        f.write("-- Unit 1 Questions (Limits) â€” CLEAN REPLACE\n")
        f.write("-- Generated by Antigravity\n")
        f.write("-- ============================================================\n")
        f.write("BEGIN;\n\n")

        # Step 0: Definitions
        f.write("-- Step 0: Ensure topic_content + skills + error_tags\n")
        
        # Topics
        if topics:
            f.write("INSERT INTO public.topic_content (id, title, description) VALUES\n")
            topic_lines = []
            for t_id, t_data in topics.items():
                topic_lines.append(f"  ({escape_sql(t_id)}, {escape_sql(t_data['title'])}, {escape_sql(t_data['description'])})")
            f.write(",\n".join(topic_lines))
            f.write("\nON CONFLICT (id) DO NOTHING;\n\n")

        # Skills
        if skills:
            f.write("INSERT INTO public.skills (id, name, unit) VALUES\n")
            skill_lines = []
            for s_id, s_data in skills.items():
                skill_lines.append(f"  ({escape_sql(s_id)}, {escape_sql(s_data['name'])}, {escape_sql(s_data['unit'])})")
            f.write(",\n".join(skill_lines))
            f.write("\nON CONFLICT (id) DO NOTHING;\n\n")

        # Error Tags
        if error_tags:
            f.write("INSERT INTO public.error_tags (id, name, unit, severity, category) VALUES\n")
            et_lines = []
            for e_id, e_data in error_tags.items():
                et_lines.append(f"  ({escape_sql(e_id)}, {escape_sql(e_data['name'])}, {escape_sql(e_data['unit'])}, {e_data['severity']}, {escape_sql(e_data['category'])})")
            f.write(",\n".join(et_lines))
            f.write("\nON CONFLICT (id) DO NOTHING;\n\n")
            
        # Step 1: Constraints (from template)
        f.write("-- Step 1: Expand representation_type constraint\n")
        f.write("ALTER TABLE public.questions DROP CONSTRAINT IF EXISTS questions_representation_type_check;\n")
        f.write("ALTER TABLE public.questions ADD CONSTRAINT questions_representation_type_check\n")
        f.write("  CHECK (representation_type::text = ANY (ARRAY['symbolic','graph','table','verbal','mixed','text','image']::text[]));\n\n")
        
        # Step 2: Disable Triggers
        f.write("-- Step 2: Disable user triggers (version trigger)\n")
        f.write("ALTER TABLE public.questions DISABLE TRIGGER USER;\n\n")

        # Step 3: Nuke old questions
        f.write("-- Step 3: Nuke ALL Unit 1.1/1.2 questions (and their FK refs)\n")
        
        # We delete by sub_topic_id AND topic_id to be safe
        # Construct the IN clause
        sub_topics_sql = ", ".join([f"'{st}'" for st in unique_sub_topics])
        topic_ids_sql = ", ".join([f"'{tid}'" for tid in unique_topic_ids])
        
        tables_to_clean = [
            'public.question_skills',
            'public.question_error_patterns',
            'public.question_versions',
            'public.user_question_state',
            'public.recommendations',
            'public.question_attempts',
            'public.questions' # Last
        ]
        
        # DELETE 1: match on sub_topic_id IN (...) AND topic_id IN (...)
        if sub_topics_sql and topic_ids_sql:
            where_clause = f"sub_topic_id IN ({sub_topics_sql}) AND topic_id IN ({topic_ids_sql})"
            for tbl in tables_to_clean:
                if tbl == 'public.questions':
                     f.write(f"DELETE FROM {tbl} WHERE {where_clause};\n")
                else:
                     f.write(f"DELETE FROM {tbl} WHERE question_id IN (SELECT id FROM public.questions WHERE {where_clause});\n")
            f.write("\n")

        # Step 4: Insert new questions
        f.write("-- Step 4: Insert new questions\n")
        
        columns = [
            'id', 'course', 'topic', 'sub_topic_id', 'type', 'calculator_allowed', 'difficulty', 'target_time_seconds',
            'skill_tags', 'error_tags', 'prompt', 'latex', 'options', 'correct_option_id', 'tolerance',
            'explanation', 'micro_explanations', 'recommendation_reasons', 'created_by', 'created_at', 'updated_at',
            'status', 'version', 'reasoning_level', 'mastery_weight', 'representation_type', 'topic_id', 'section_id',
            'source', 'source_year', 'notes', 'weight_primary', 'weight_supporting', 'title', 'prompt_type',
            'primary_skill_id', 'supporting_skill_ids'
        ]
        
        for i, q in enumerate(questions):
            f.write(f"-- Q{i+1}\n")
            
            vals = []
            for col in columns:
                if col == 'id':
                    vals.append("gen_random_uuid()")
                elif col == 'options':
                     # Ensure it's jsonb literal
                     escaped = escape_sql(q.get('options'))
                     vals.append(f"{escaped}::jsonb")
                elif col == 'micro_explanations':
                     escaped = escape_sql(q.get('micro_explanations'))
                     vals.append(f"{escaped}::jsonb")
                elif col in ['skill_tags', 'error_tags', 'recommendation_reasons', 'supporting_skill_ids']:
                    # Array types
                    arr_val = q.get(col, [])
                    vals.append(escape_array(arr_val))
                elif col == 'difficulty':
                    diff = q.get('difficulty')
                    if isinstance(diff, str) and diff.startswith('Level'):
                        try:
                            vals.append(str(int(diff.replace('Level', ''))))
                        except:
                            vals.append(escape_sql(diff))
                    else:
                        vals.append(escape_sql(diff))
                elif col == 'reasoning_level':
                    rl = q.get('reasoning_level')
                    reasoning_map = {
                        "recall": 1,
                        "conceptual": 2,
                        "procedural": 3,
                        "strategic": 4,
                        "extended": 5
                    }
                    if isinstance(rl, str):
                        rl_lower = rl.lower()
                        if rl_lower in reasoning_map:
                             vals.append(str(reasoning_map[rl_lower]))
                        else:
                             vals.append(escape_sql(rl))
                    else:
                        vals.append(escape_sql(rl))
                elif col in ['created_at', 'updated_at']:
                    # Check if in JSON, else use SQL literal
                    if col in q:
                         vals.append(escape_sql(q[col]))
                    else:
                         vals.append(escape_sql("2026-02-07 00:00:00+00")) # Fallback
                else:
                    vals.append(escape_sql(q.get(col)))
            
            f.write(f"INSERT INTO public.questions ({', '.join(columns)}) VALUES (\n")
            f.write("  " + ", ".join(vals) + "\n);\n\n")

        # Step 5: Enable Triggers
        f.write("-- Step 5: Re-enable triggers\n")
        f.write("ALTER TABLE public.questions ENABLE TRIGGER USER;\n\n")
        
        f.write("COMMIT;\n")

    print(f"Generated SQL in {output_file}")

if __name__ == "__main__":
    main()
